# Callysto

**Callysto** is a [Python](http://www.python.org/) framework to create domain-specific kernels for the [Jupyter](http://jupyter.org/) notebook platform. All you have to do is to extend a class `BaseKernel` and overload its method `do_execute_()`. This methods receives whatever the user types in the notebook, and is expected to return one or more content frames (using the `yield` statement), which are rendered then sent to the notebook. That's it! No need to deal with exceptions or MIME type; **Callysto** does it for you. **Callysto** also simplifies the process of installing kernels or launching them.

**Callysto** comes with built-in renderers for basic MIME types (text, PNG, GIF, JPG, SVG, HTML and Javascript documents). Additional renderers can be developed by extending the `BaseRenderer` class. For example, a [Graphviz](http://www.graphviz.org/)-based graph renderer is provided to display networks.

Example kernels developed with **Callysto** are provided as a [separate repository](https://github.com/ajmazurie/callysto-examples).

## Quick examples

An 'echo' kernel, returning the user input:

```python
import callysto

class MyKernel (callysto.BaseKernel):
	def do_execute_ (self, code):
		# very simple kernel echoing the user's input
		yield code

if (__name__ == "__main__"):
    MyKernel.launch()
```

A dummy kernel echoing the user input and also producing a CSV table (rendered as an HTML table):

```python
class MyKernel (callysto.BaseKernel):
	def do_execute_ (self, code):
		# first echo the input code, but in uppercase
		yield code.upper()
		# then return a CSV table
		table = (("column_1", "column_2"),
			     ("value_1", "value_2"))
		yield (callysto.MIME_TYPE.CSV_WITH_HEADER, table)
```

## Magic commands

**Callysto** provides non-nonsense, IPython-inspired magic commands that can run either on the user code before it is sent to your `do_execute_()` method (*pre-flight* commands), or run on the results generated by your method after it runs (*post-flight* commands). These magic commands can accept options as defined by a simple documentation, and handled by the excellent [docopt](http://docopt.org/) library:

```python
class MyKernel (callysto.BaseKernel):
	# method called when the kernel is initialized
	def do_startup_ (self, **kwargs):
		# change the prefix of the magic commands from its default '%'
		self.magic_commands.prefix = '!'

		# simple magic command, without options
		self.declare_pre_flight_command(
			"uppercase", lambda x: x.upper())

		# more complex magic command, with options
		def add_prefix (code, **kwargs):
			""" Add a prefix to the input code

				Usage:
					add_prefix [--prefix STRING]

				Options:
					--prefix STRING  Add a prefix [default: >]
			"""
			prefix = kwargs["--prefix"]  # optional; '>' by default
			return prefix + code

		self.declare_pre_flight_command(
			"add-prefix", add_prefix)
	...
```

Now whenever the user inputs something like this:

```
!uppercase
!add-prefix --prefix {
test
```

Then your `do_execute_()` method will receive the string `{TEST`. This is because the `uppercase` magic command will be called first, transforming the user's code to uppercase. Then `add-prefix` will be called, adding the prefix `{` to this code. Very useful to pre-process user's input.

## Roadmap

- [ ] Implementation of code completion mechanisms
- [ ] Development of a [Vega](http://vega.github.io/vega/) content renderer

**Current version: 0.2 (February 25, 2016)**
