# Callysto

**Callysto** is a project to create a simple, Python-based kernel for the [Jupyter](http://jupyter.org/) notebook platform. All you have to do is to extend a class `BaseKernel` and overload its method `do_execute_()`; a couple more methods can be optionally overloaded as well, for example to setup and destroy an environment (database connection, etc.)

The `do_execute_()` method will be called whenever the notebook user send a command to your kernel, and is expected to return one or more pieces of data (text, images, etc.) that will be shown to the user. That's it! Here is an example:

```python
import callysto

class MyKernel (callysto.BaseKernel):
	def do_execute_ (self, code):
		# very simple kernel echoing the user's input
		return code

if (__name__ == "__main__"):
    callysto.launch_kernel(MyKernel)
```

**Callysto** handles all the basics you would expect, such as exceptions and common mimetypes. Your `do_execute_()` method can return a string, a list of HTML documents, or even CSV-formatted data; **Callysto** will nicely display it all to the user:

```python
class MyKernel (callysto.BaseKernel):
	def do_execute_ (self, code):
		# first echo the input code, but in uppercase
		yield code.upper()
		# then return a CSV table
		table = (("column_1", "column_2"),
			     ("value_1", "value_2"))
		yield (callysto.content.CSV_WITH_HEADER, table)
```

**Callysto** also provide non-nonsense, IPython-inspired magic commands that can run either on the user code before it is sent to your `do_execute_()` method (*pre-flight* commands), or run on the results generated by your method after it runs (*post-flight* commands). These magic commands can accept options as defined by a simple documentation, and handled by the excellent [docopt](http://docopt.org/) library:

```python
class MyKernel (callysto.BaseKernel):
	# method called when the kernel is initialized
	def do_startup_ (self, **kwargs):
		# simple magic command, without options
		self.magic_commands.declare_pre_flight_command(
			"uppercase", lambda x: x.upper())

		# more complex magic command, with options
		def add_prefix (code, **options):
			""" Add a prefix to the input code

				Usage:
					add_prefix [--prefix STRING]
					
				Options:
					--prefix STRING  Add a prefix [default: >]
			"""
			prefix = options["--prefix"]  # optional; '>' by default
			return prefix + code

		self.magic_commands.declare_pre_flight_command(
			"add-prefix", add_prefix)
	...
```

Now whenever the user inputs something like this:

```
%uppercase
%add-prefix --prefix {
test
```	

Then your `do_execute_()` method will receive the string `{TEST`. This is because the `uppercase` magic command will be called first, transforming the user's code to uppercase. Then `add-prefix` will be called, adding the prefix `{` to this code. Very useful to pre-process user's input.

You can even change the prefix from the default `%` symbol to anything you want to accomodate domain-specific languages (e.g., `%` would be a problem if you're trying to write a kernel to process SQL commands):

```python
class MyKernel (callysto.BaseKernel):
	# method called when the kernel is initialized
	def do_startup_ (self, **kwargs):
		self.magic_commands.prefix = '!'
		self.magic_commands.declare_pre_flight_command(
			"uppercase", lambda x: x.upper())
	...
```
